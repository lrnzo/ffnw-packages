#!/usr/bin/lua

local pidPath="/var/run/hoodselector.pid"

if io.open(pidPath, "r") ~=nil then
	io.stderr:write("The hoodselector is still running.\n")
	os.exit(1)
else
	io.close(io.open(pidPath, "w"))
end

function pid_clean()
	if io.open(pidPath, "r") ~=nil then
		os.remove(pidPath)
	end
end

local json = require ("dkjson")
local file = '/lib/ffnw/hoods/hoods.json'
local uci = require('luci.model.uci').cursor()

-- Read the full hoodfile. Return nil for wrong format or no such file
local function readhoodfile(file)
	local obj, pos, err = json.decode (io.popen(string.format("cat %s",file), 'r'):read('*a'), 1, nil)
	if err then
		return nil
	else
		return obj
	end
end

-- Return a wifi device list
local function get_wifi_devices()
	local radios = {}
	uci:foreach('wireless', 'wifi-device',
		function(s)
			table.insert(radios, s['.name'])
		end
	)
	return radios
end

-- Get Geoposition if no static position present try lwtrace. Return nil for no position
local function get_geolocation()
	local lat = uci:get('gluon-node-info', uci:get_first('gluon-node-info', 'location'), 'latitude')
	local lng = uci:get('gluon-node-info', uci:get_first('gluon-node-info', 'location'), 'longitude')
	if ( lat == nil or lng == nil ) then
		for scan in io.popen(string.format("lwtrace -t 2> /dev/null"), 'r'):lines() do
			if string.find(scan,"(lat)") then
				local last_val = nil
				for geo in string.gmatch(scan,"[^%s]+") do
					if geo == '(lat)' then
						lat = last_val
					end
					if geo == '(lon)' then
						lng = last_val
					end
					last_val = geo
				end
			end
		end
	end
	local ret = {}
	table.insert(ret, tonumber(lat))
	table.insert(ret, tonumber(lng))
	return ret
end

-- Return hood from the hood file based on geo position. This method
-- can return the following data:
-- * real hood if a hood could be determined for the given position
-- * nil if no real hood could be determined
local function gethood_by_geo(jhood,geo)
	for n, h in pairs(jhood) do
		for n, box in pairs(h.boxes) do
			if ( geo[1] >= box[1][1] and geo[1] < box[2][1] and geo[2] >= box[1][2] and geo[2] < box[2][2] ) then
				return h
			end
		end
	end
	return nil
end

-- Return hood from the hood file based on a given BSSID. This method
-- takes a BSSID and returns the real hood that coresponds to the BSSIDs.
-- This method can return the following data:
-- * real hood if a real hood matches the given BSSID
-- * nil if no real hood could be found
local function gethood_by_bssid(jhood, scan_bssid)
	for n, h in pairs(jhood) do
		if scan_bssid:match(h.bssid) then
			return h
		end
	end
	return nil
end

-- Return the default hood in the hood list.
-- This method can return the following data:
-- * default hood
-- * nil if no default hood has been defined
local function get_default_hood(jhood)
	for n, h in pairs(jhood) do
		if h.defaulthood then
			return h
		end
	end
	return nil
end

-- boolean check if batman-adv has gateways
local function get_gw_range()
	local gw_connect = false
	for gw in io.popen(string.format("cat /sys/kernel/debug/batman_adv/bat0/gateways"), 'r'):lines() do
		if gw:match("Bit") then
			gw_connect = true
		end
	end
	return gw_connect
end

--Load bssid history
function bssid_hist_load( sfile )
	local bssid_his = {}
	for line in io.popen(string.format("cat %s 2> /dev/null",sfile),'r'):lines() do
		if line:match("(%w+:%w+:%w+:%w+:%w+:%w+)") then
			table.insert(bssid_his,line)
		end
	end
	return bssid_his
end

--Save bssid history
function bssid_hist_save( tbl,filename )
	local file,err = io.open( filename, "wb" )
	if err then return err end
	for idx,str in ipairs( tbl ) do
		file:write(str)
	end
	file:close()
end

-- Return the BSSID from the next freifunk router with the best signal quality and with has a difference to the actual used BSSID
local function get_neigbour_bssid(radios)
	local hoodbssid = nil
	local bssid_leases = bssid_hist_load("/tmp/hoodselector.leases")
	for index, radio in ipairs(radios) do
		hoodbssid = uci:get('wireless', 'ibss_' .. radio, 'bssid')
		local bssid_his = ""
		if bssid_leases[index] ~= nil then
			bssid_his = bssid_leases[index]
		end
		bssid_his = bssid_his..' '..hoodbssid
		local lastQuality = 255
		local tmphoodbssid = nil
		for wifiscan in io.popen(string.format("iw %s scan | grep \"%s\" -B8", uci:get('wireless', 'ibss_' .. radio, 'ifname'), uci:get('wireless', 'ibss_' .. radio, 'ssid')),'r'):lines() do
			if wifiscan:match("(%w+:%w+:%w+:%w+:%w+:%w+)") then
				tmphoodbssid = wifiscan:match("(%w+:%w+:%w+:%w+:%w+:%w+)"):upper()
			end
			if wifiscan:match("signal:") then
				local quallity = wifiscan:split(" ")
				quallity = quallity[2]:split(".")
				if quallity[1]:match("-") then
					quallity = quallity[1]:split("-")
				end
				quallity = tonumber(quallity[2]:match("(%d%d)"))
				if not bssid_his:match(tmphoodbssid) then
					if ( lastQuality > quallity ) then
						lastQuality = quallity
						hoodbssid = tmphoodbssid
					end
				end
			end
		end
		if ( lastQuality == 255 ) then
			bssid_his = bssid_his:split(" ")
			hoodbssid = bssid_his[2]
			bssid_his = ""
		end
		bssid_leases[index] = bssid_his
	end
	bssid_hist_save(bssid_leases,"/tmp/hoodselector.leases")
	return hoodbssid
end

-- Retun a table of current peers from /etc/config/fastd
local function get_current_peers()
	local config_peername = {}
	uci:foreach('fastd', 'peer',
		function(s)
			if s['.name'] then
				table.insert(config_peername,s)
			end
		end
	)
	local config_peers = {}
	for _,index in pairs(config_peername) do
		for prafix,peer in pairs(index) do
			local tmp_peer = {}
			if prafix:match(".name") then
				if peer:match("mesh_vpn_backbone_peer_") then
					local tmpremote = uci:get('fastd', peer, 'remote')
					tmpremote = tmpremote[1]:split(" ")
					local remote = {}
					remote['host'] = tmpremote[1]
					remote[tmpremote[2]] = tmpremote[3]
					tmp_peer['key'] = tostring(uci:get('fastd', peer, 'key'))
					tmp_peer['remote'] = remote
					config_peers[peer] = tmp_peer
				end
			end
		end
	end
	return config_peers
end

--Remove current peers that is not exist in the current hood. Check the integrity and add new peers
local function set_hoodconfig(hood,radios)
	local change = false
	local uci_error = false
	local config_peers = get_current_peers()
	for hoodconf,val in pairs(hood) do
		if hoodconf:match("servers") then
			for config_index, config_peer in pairs(config_peers) do
				local remove = true
				local hood_server = nil
				for index0,serverlist in pairs(val) do
					for index1,server in pairs(serverlist) do
						if index1:match("host") then
							local hoodserver = server:split('.')
							if config_index == 'mesh_vpn_backbone_peer_'..hoodserver[1] then
								remove = false
								hood_server = index0
								if not ( config_peer.key == serverlist['publickey'] ) then
									local err = uci:set('fastd', config_index, 'key', serverlist['publickey'])
									if not err then
										uci_error = true
									end
									change = true
								end
								server = '\"'..server..'\"'
								if not ( config_peer.remote.host == server ) then
									local hood_remote = {}
									table.insert(hood_remote, server..' port '..config_peer.remote.port)
									local err uci:set('fastd', config_index, 'remote', hood_remote)
									if not err then
										uci_error = true
									end
									change = true
								end
								if not ( config_peer.remote.port == serverlist['port'] ) then
									local hood_remote = {}
									table.insert(hood_remote, config_peer.remote.host..' port '..serverlist['port'])
									local err uci:set('fastd', config_index, 'remote', hood_remote)
									if not err then
										uci_error = true
									end
									change = true
								end
							end
						end
					end
				end
				if remove then
					uci:delete('fastd',config_index)
					change = true
				else
					if hood_server ~= nil then
						table.remove(val,hood_server)
					end
				end
			end
		end
		if hoodconf:match("bssid") then
			local if_change = false
			for index, radio in ipairs(radios) do
				if not ( uci:get('wireless', 'ibss_' .. radio, 'bssid') == val ) then
					uci:section('wireless', 'wifi-iface', 'ibss_' .. radio,
						{
							bssid = val
						}
					)
					if_change = true
				end
			end
			if if_change then
				uci:save('wireless')
				uci:commit('wireless')
				os.execute('wifi')
			end
		end
	end
	for hoodconf,val in pairs(hood) do
		if hoodconf:match("servers") then
			for index0,serverlist in pairs(val) do
				local group = 'mesh_vpn_backbone'
				local name = serverlist.host:split('.')
				name = name[1]
				local remote = {}
				table.insert(remote, '\"'..serverlist.host..'\"'..' port '..serverlist.port)
				uci:section('fastd', 'peer', group .. '_peer_' .. name,
					{
						enabled = 1,
						net = 'mesh_vpn',
						group = group,
						key = serverlist.publickey,
						remote = remote
					}
				)
				change = true
			end
		end
	end
	if change then
		uci:save('fastd')
		uci:commit('fastd')
		os.execute('/etc/init.d/fastd restart')
	end
	if uci_error then
		return false
	end
	return true
end

function exit()
	pid_clean()
	os.exit(0)
end

--Start
local jhood = readhoodfile(file)
if jhood ~= nil then
	local radios = get_wifi_devices()
	local geo = get_geolocation()
	if geo[1] ~= nil or geo[2] ~= nil then
		local geo_hood = gethood_by_geo(jhood, geo)
		if geo_hood ~= nil then
			local no_error = set_hoodconfig(geo_hood,radios)
			if no_error then
				io.stderr:write('Setting hood getting from position.\n')
				exit()
			end
			io.stderr:write('Error while setting new hood getting by geoposition.\n')
			exit()
		end
		io.stderr:write('No hood has been defined for current position.\n')
		local defaultHood = get_default_hood(jhood)
		if defaultHood ~= nil then
			local no_error = set_hoodconfig(defaultHood, radios)
			if no_error then
				io.stderr:write('Setting defaulthood.\n')
				exit()
			end
			io.stderr:write('Error while setting defaulthood.\n')
			exit()
		end
		io.stderr:write('No defaulthood has been defined.\n')
		exit()
	end
	io.stderr:write('Router dont have a position.\n')
	if get_gw_range() then
		exit()
	end
	if next(radios) then
		local scan_bssid = get_neigbour_bssid(radios)
		if scan_bssid ~= nil then
			local bssid_hood = gethood_by_bssid(jhood, scan_bssid)
			if bssid_hood ~= nil then
				local no_error = set_hoodconfig(bssid_hood,radios)
				if no_error then
					io.stderr:write('Setting hood getting from bssid.\n')
					exit()
				end
				io.stderr:write('Error while setting new hood getting by bssid.\n')
				exit()
			end
			io.stderr:write('No hood has been defined for scanned bssid.\n')
			exit()
		end
	end
	io.stderr:write('There ara no wifi chipsets detected.\n')
	exit()
end
io.stderr:write('There seems to have gone something wrong while reading hoodfile from ' .. file .. '\n')
exit()
