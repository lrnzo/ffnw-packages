#!/usr/bin/lua

-- This is the hoodselector. The hoodselector is one of the main components for
-- splitting a layer 2 mesh network into seperated network segments (hoods).
-- The job of the hoodselector is to automatically detect in which hood
-- the router is located based on geo settings or by scanning its environment.
-- Based on these informations the hoodselector should select a hood from a
-- list of known hoods (hoodlist) and adjust vpn, wireless and mesh on lan (TODO)
-- configuration based on the settings given for the selected hood.
--
-- The hoodlist containing all hood settings is located in a seperate hoodfile
-- in the hoods package.
--
-- The hoodselector depends on the folowing additional software:
--  * fastd (vpn configuration) see getCurrentPeers(), setHoodVPN()
--  * iw (wireless network scanning) see getNeigbourBssid()
--  * batman-adv (mesh protocol) see directVPN(), getGwRange()
--  * lwtrace (geolocator) see getGeolocation()
--
--  To detect the current hood the hoodselector knows 2 modes containing
--  * 1. Default mode (VPN Router)
--    - set real hood dependent on geo position.
--    - set default hood dependent on geo position.
--  * 2. Scan modes
--   - Set wifi conf on scanned BSSID
--   - Set vpn conf getting by BSSID (if no VPN conf exsist disable fastd)
-- When selecting a hood, the hoodselector has the following priorities:
--   1. Selecting a hood by geo position depending on direct VPN connection.
--   2. force creating one mesh cloud with neigbour mesh routers
--   3. if routers had only mesh setting vpn config depends on the BSSID
--
-- Resources
--  * https://wireless.wiki.kernel.org/en/users/documentation/iw

-- PID file to ensure the hoodselector isn't running parallel
local pidPath="/var/run/hoodselector.pid"

if io.open(pidPath, 'r') ~= nil then
  io.stderr:write("The hoodselector is still running.\n")
  os.exit(1)
else
  io.close(io.open(pidPath, 'w'))
end

local json = require ('dkjson')
local uci = require('luci.model.uci').cursor()
local file = "/lib/ffnw/hoods/hoods.json"
-- initialization done

-- Read the full hoodfile. Return nil for wrong format or no such file
local function readHoodfile(file)
  local jhood = io.open(file, 'r')
  if not jhood then return nil end
  local obj, pos, err = json.decode (jhood:read('*a'), 1, nil)
  if err then
    return nil
  else
    return obj
  end
end

-- Program terminating function including removing of PID file
local function exit()
  if io.open(pidPath, 'r') ~= nil then
    os.remove(pidPath)
  end
  os.exit(0)
end

-- Get a list of wifi devices return an emty table for no divices
local function getWifiDevices()
  local radios = {}
  uci:foreach('wireless', 'wifi-device',
    function(s)
      table.insert(radios, s['.name'])
    end
  )
  return radios
end

-- bool if direct VPN. The detection is realaise by searching the fastd network interface inside the originator table
local function directVPN()
  for outgoingIF in io.open("/sys/kernel/debug/batman_adv/bat0/originators", 'r'):lines() do
    if outgoingIF:match(string.gsub("%[  " .. uci:get('fastd', 'mesh_vpn_backbone', 'net') .. "%]","%_",'-'):gsub("%-", "%%-")) then
      return true
    end
  end
  return false
end

-- Get Geoposition if no static position present try lwtrace. Return nil for no position
local function getGeolocation()
  local lat = uci:get('gluon-node-info', uci:get_first('gluon-node-info', 'location'), 'latitude')
  local lng = uci:get('gluon-node-info', uci:get_first('gluon-node-info', 'location'), 'longitude')
  if ( lat == nil or lng == nil ) then
    for scan in io.popen(string.format("lwtrace -t 2> /dev/null"), 'r'):lines() do
      if string.find(scan,"(lat)") then
	local last_val = nil
	for geo in string.gmatch(scan,"[^%s]+") do
	  if geo == "(lat)" then
	    lat = last_val
	  end
	  if geo == "(lon)" then
	    lng = last_val
	  end
	  last_val = geo
	end
      end
    end
  end
  local ret = {}
  table.insert(ret, tonumber(lat))
  table.insert(ret, tonumber(lng))
  return ret
end

-- Return hood from the hood file based on geo position or nil, no real hood could be determined
local function getHoodByGeo(jhood,geo)
  for n, h in pairs(jhood) do
    for n, box in pairs(h.boxes) do
      if ( geo[1] >= box[1][1] and geo[1] < box[2][1] and geo[2] >= box[1][2] and geo[2] < box[2][2] ) then
	return h
      end
    end
  end
  return nil
end

-- reconfigures the bssid if needed
-- returns true
-- returns false for error while setting bssid via UCI
local function setHoodWifi(hoodBssid,radios)
  local ret = true
  local change = false
  for index, radio in ipairs(radios) do
    if not ( uci:get('wireless', 'ibss_' .. radio, 'bssid') == hoodBssid) then
      ret = uci:section('wireless', 'wifi-iface', 'ibss_' .. radio,
        {
          bssid = hoodBssid
        }
      )
      change = true
    end
  end
  if change then
    uci:save('wireless')
    uci:commit('wireless')
    os.execute('wifi')
  end
  return ret
end

-- Retun a table of current peers from /etc/config/fastd
local function getCurrentPeers()
  local configPeername = {}
  local configPeers = {}
  uci:foreach('fastd', 'peer',
    function(s)
      if s['.name'] then
	table.insert(configPeername,s)
      end
    end
  )
  for _,index in pairs(configPeername) do
    for prefix,peer in pairs(index) do
      local tmpPeer = {}
      if prefix:match(".name") then
	if peer:match("mesh_vpn_backbone_peer_") then
	  local tmpRemote = uci:get('fastd', peer, 'remote')
	  tmpRemote = tmpRemote[1]:split(' ')
	  local remote = {}
	  remote['host'] = tmpRemote[1]
	  remote[tmpRemote[2]] = tmpRemote[3]
	  tmpPeer['key'] = tostring(uci:get('fastd', peer, 'key'))
	  tmpPeer['remote'] = remote
	  configPeers[peer] = tmpPeer
	end
      end
    end
  end
  return configPeers
end

-- This method sets a new fastd config and takes care that services are only
-- stopped or restarted if reconfiguration is needed.
-- return true
-- return false for getting error while setting config via UCI
local function setHoodVPN(hood)
  local change = false
  local uciError = false
  local configPeers = getCurrentPeers()
  for configIndex, configPeer in pairs(configPeers) do
    local remove = true
    local hoodserver0 = nil
    for index0,serverlist in pairs(hood.servers) do
      for index1,server in pairs(serverlist) do
	if index1:match("host") then
	  local hoodserver1 = server:split('.')
	  if configIndex == "mesh_vpn_backbone_peer_" .. hoodserver1[1] then
	    remove = false
	    hoodserver0 = index0
	    if not ( configPeer.key == serverlist['publickey'] ) then
	      if not uci:set('fastd', configIndex, 'key', serverlist['publickey']) then
		uciError = true
	      end
	      change = true
	    end
	    server = '\"'..server..'\"'
	    if not ( configPeer.remote.host == server ) then
	      local hoodRemote = {}
	      table.insert(hoodRemote, server .. ' port ' .. configPeer.remote.port)
	      if not uci:set('fastd', configIndex, 'remote', hoodRemote) then
		uciError = true
	      end
	      change = true
	    end
	    if not ( configPeer.remote.port == serverlist['port'] ) then
	      local hoodRemote = {}
	      table.insert(hoodRemote, configPeer.remote.host .. ' port ' .. serverlist['port'])
	      if not uci:set('fastd', configIndex, 'remote', hoodRemote) then
		uciError = true
	      end
	      change = true
	    end
	  end
	end
      end
    end
    if remove then
      uci:delete('fastd',configIndex)
      change = true
    else
      if hoodserver0 ~= nil then
	table.remove(hood.servers,hoodserver0)
      end
    end
  end
  for index0,serverlist in pairs(hood.servers) do
    local group = 'mesh_vpn_backbone'
    local name = serverlist.host:split('.')
    name = name[1]
    local remote = {}
    table.insert(remote, '\"'..serverlist.host..'\"'..' port '..serverlist.port)
    uci:section('fastd', 'peer', group .. '_peer_' .. name,
      {
	enabled = 1,
	net = 'mesh_vpn',
	group = group,
	key = serverlist.publickey,
	remote = remote
      }
    )
    change = true
  end
  if change then
    uci:save('fastd')
    uci:commit('fastd')
    os.execute('/etc/init.d/fastd restart 2> /dev/null')
  end
  if uciError then
    return false
  end
  return true
end

-- Return the default hood in the hood list.
-- This method can return the following data:
-- * default hood
-- * nil if no default hood has been defined
local function getDefaultHood(jhood)
  for n, h in pairs(jhood) do
    if h.defaulthood then
      return h
    end
  end
  return nil
end

-- This functions "Load bssid history" and "Save bssid history" will stored a 
-- history list of tryed nighbour BSSIDs over the cron intervall

-- Load bssid history
local function bssid_hist_load(sfile)
  local bssid_his = {}
  local sfileO = io.open(sfile, r)
  if not sfileO then return bssid_his end
  for line in sfileO:lines() do
    if line:match("(%w+:%w+:%w+:%w+:%w+:%w+)") then
      table.insert(bssid_his,line)
    end
  end
  sfileO:close()
  return bssid_his
end

-- Save bssid history
local function bssid_hist_save(tbl,filename)
  local file = io.open( filename, "wb" )
  if not file then return nil end
  for idx,str in ipairs( tbl ) do
    file:write(str)
  end
  file:close()
end

-- Return the BSSID from the next freifunk router with the best signal quality and with has a difference to the actual used BSSID
local function getNeigbourBssid(radios)
  local hoodbssid = nil
  local bssid_leases = bssid_hist_load("/tmp/hoodselector.leases")
  for index, radio in ipairs(radios) do
    hoodbssid = uci:get('wireless', 'ibss_' .. radio, 'bssid')
    local bssid_his = ''
    if bssid_leases[index] ~= nil then
      bssid_his = bssid_leases[index]
    end
    bssid_his = bssid_his..' '..hoodbssid
    local lastQuality = 255
    local tmphoodbssid = nil
    for wifiscan in io.popen(string.format("iw %s scan | grep \"%s\" -B8", uci:get('wireless', 'ibss_' .. radio, 'ifname'), uci:get('wireless', 'ibss_' ..radio, 'ssid')),'r'):lines() do
      if wifiscan:match("(%w+:%w+:%w+:%w+:%w+:%w+)") then
	tmphoodbssid = wifiscan:match("(%w+:%w+:%w+:%w+:%w+:%w+)"):upper()
      end
      if wifiscan:match("signal:") then
	local quallity = wifiscan:split(' ')
	quallity = quallity[2]:split('.')
	if quallity[1]:match('-') then
	  quallity = quallity[1]:split('-')
	end
	quallity = tonumber(quallity[2]:match("(%d%d)"))
	if not bssid_his:match(tmphoodbssid) then
	  if ( lastQuality > quallity ) then
	    lastQuality = quallity
	    hoodbssid = tmphoodbssid
	  end
	end
      end
    end
    if ( lastQuality == 255 ) then
      bssid_his = ''
    end
    bssid_leases[index] = bssid_his
  end
  bssid_hist_save(bssid_leases,"/tmp/hoodselector.leases")
  return hoodbssid
end

-- boolean check if batman-adv has gateways
local function getGwRange()
  for gw in io.open("/sys/kernel/debug/batman_adv/bat0/gateways", 'r'):lines() do
    if gw:match("Bit") then
      return true
    end
  end
  return false
end

-- Return hood from the hood file based on a given BSSID. nil if no matching hood could be found
local function gethoodByBssid(jhood, scan_bssid)
  for n, h in pairs(jhood) do
    if scan_bssid:match(h.bssid) then
      return h
    end
  end
  return nil
end

--Start
--Read hoods json file
local jhood = readHoodfile(file)
if jhood == nil then
  io.stderr:write("There seems to have gone something wrong while reading hoodfile from " .. file .. '\n')
  exit()
end
-- Get list of wifi devices
local radios = getWifiDevices()

--If direct vpn, sed hood by geo.
if directVPN() then
  local geo = getGeolocation()
  if geo[1] ~= nil and geo[2] ~= nil then
    local geoHood = getHoodByGeo(jhood, geo)
    if geoHood ~= nil then
      if setHoodWifi(geoHood.bssid,radios) and setHoodVPN(geoHood) then
        io.stderr:write('Setting hood getting from position.\n')
        exit()
      end
        io.stderr:write('Error while setting new hood getting by geoposition.\n')
        exit()
    end
    io.stderr:write('No hood has been defined for current position.\n')
    local defaultHood = getDefaultHood(jhood)
    if defaultHood ~= nil then
      if setHoodWifi(defaultHood.bssid,radios) and setHoodVPN(defaultHood) then
	io.stderr:write('Setting defaulthood.\n')
	exit()
      end
      io.stderr:write('Error while setting defaulthood.\n')
      exit()
    end
  end
  io.stderr:write('Router dont have a position.\n')
end

if next(radios) then
  -- If no direct VPN and batman GWs not in range set scanned bssid
  local scanBssid = getNeigbourBssid(radios)
  if scanBssid ~= nil then
    if not getGwRange() then
      if setHoodWifi(scanBssid,radios) then
        io.stderr:write('Setting Bssid getting from Scan.\n')
      else
        io.stderr:write('Error while setting Bssid getting from Scan.\n')
        exit()
      end
    end

    -- Set VPN config getting by BSSID
    local bssidHood = gethoodByBssid(jhood, scanBssid)
    if bssidHood ~= nil then
      if setHoodVPN(bssidHood) then
	io.stderr:write('Setting hood getting from bssid.\n')
	os.execute('/etc/init.d/fastd start 2> /dev/null')
	os.execute('/etc/init.d/fastd enable')
	exit()
      end
      io.stderr:write('Error while setting new hood getting by bssid.\n')
      exit()
    end
    io.stderr:write('No hood has been defined for scanned bssid.\n')
    os.execute('/etc/init.d/fastd stop 2> /dev/null')
    os.execute('/etc/init.d/fastd disable')
    exit()
  end
  io.stderr:write('Error while scanning wifi.\n')
end
exit()
